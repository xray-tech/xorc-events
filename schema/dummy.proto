package dummy;


message Dummy {
  optional string string_field = 1;
  optional int32 int32_field = 2;
  optional int64 int64_field = 3;
  optional uint32 uint32_field = 4;
  optional uint64 uint64_field = 5;
  optional double double_field = 6;
  optional bool bool_field = 7;

  repeated string repeated_string_field = 8;
  repeated int32 repeated_int32_field = 9;
  repeated int64 repeated_int64_field = 10;
  repeated uint32 repeated_uint32_field = 11;
  repeated uint64 repeated_uint64_field = 12;
  repeated double repeated_double_field = 13;
  repeated bool repeated_bool_field = 14;

  enum Enum {
    FIRST = 0;
    SECOND = 1;
    RANDOM = 123;
  }

  optional Enum enum_field = 15 [default = RANDOM];

  message Internal {
    optional string test_str = 1;
  }

  optional Internal internal = 16;

  oneof test_oneof {
    string oneof_string = 17;
    Internal oneof_internal = 18;
  }
}

// The following message is for testing encoding/interop between the lua-pb library
// and the rest of the protobuf world (e.g. C++, java).

// NB: Variable length integers can use zigzag encoding to reduce space used
// to encode the value. From https://developers.google.com/protocol-buffers/docs/encoding
// If you use int32 or int64 as the type for a negative number, the resulting 
// varint is always ten bytes long â€“ it is, effectively, treated like a very large 
// unsigned integer. If you use one of the signed types, the resulting varint
// uses ZigZag encoding, which is much more efficient. 

message Test64BitIntegers
{ 
  // variable length integers. 
  optional int64  standard_ = 1;
  optional uint64 unsigned_ = 2;
  optional sint64 signed_   = 3;
    
  // fixed length, will occupy 64 bits regardless
  optional sfixed64 signed_fixed_ = 4;
  optional fixed64  fixed_ = 5;
} 
